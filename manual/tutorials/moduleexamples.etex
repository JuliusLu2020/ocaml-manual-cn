\chapter{模块系统} \label{c:moduleexamples}
%HEVEA\cutname{moduleexamples.html}

本章介绍了OCaml的模块系统。

\section{Structures}

模块的主要动机是将相关定义（例如数据类型的定义和该类型上的操作）打包在一起，并为这些定义强制赋予一致的命名模式。这样可以避免名称耗尽或意外地混淆名称。这样的包被称为结构（structure），由"struct"\ldots"end"构造引入，该结构可以包含任意定义序列。结构通常用"module"绑定来命名。例如，下面是将一种优先队列及其操作打包在一起的结构：
\begin{caml_example}{toplevel}
module PrioQueue =
  struct
    type priority = int
    type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue
    let empty = Empty
    let rec insert queue prio elt =
      match queue with
        Empty -> Node(prio, elt, Empty, Empty)
      | Node(p, e, left, right) ->
          if prio <= p
          then Node(prio, elt, insert right p e, left)
          else Node(p, e, insert right prio elt, left)
    exception Queue_is_empty
    let rec remove_top = function
        Empty -> raise Queue_is_empty
      | Node(prio, elt, left, Empty) -> left
      | Node(prio, elt, Empty, right) -> right
      | Node(prio, elt, (Node(lprio, lelt, _, _) as left),
                        (Node(rprio, relt, _, _) as right)) ->
          if lprio <= rprio
          then Node(lprio, lelt, remove_top left, right)
          else Node(rprio, relt, left, remove_top right)
    let extract = function
        Empty -> raise Queue_is_empty
      | Node(prio, elt, _, _) as queue -> (prio, elt, remove_top queue)
  end;;
\end{caml_example}
在结构外部，可以使用“点表示法”来引用其组件，即由结构名称限定的标识符。例如，"PrioQueue.insert"是在结构"PrioQueue"中定义的函数，"PrioQueue.queue"是在"PrioQueue"中定义的"queue"类型。
\begin{caml_example}{toplevel}
PrioQueue.insert PrioQueue.empty 1 "hello";;
\end{caml_example}

另一种方式是打开模块，它将模块中定义的所有标识符都放在当前结构的范围内。

\begin{caml_example}{toplevel}
  open PrioQueue;;
  insert empty 1 "hello";;
\end{caml_example}

打开模块可以更方便地访问其组件，但代价是更难识别在哪个模块中定义了哪个标识符。特别是，打开的模块可能会覆盖当前作用域中出现的标识符，从而可能导致混淆错误：

\begin{caml_example}{toplevel}
  let empty = []
  open PrioQueue;;
  let x = 1 :: empty [@@expect error];;
\end{caml_example}


这个问题的部分解决方案是在本地打开模块，使模块的组件仅在相关表达式中可用。这也可以使代码更容易阅读（模块打开语句更接近于使用它的地方）与重构（代码片段更加自包含）。为此我们可以使用如下两种结构：

\begin{caml_example}{toplevel}
  let open PrioQueue in
  insert empty 1 "hello";;
\end{caml_example}
或者
\begin{caml_example}{toplevel}
  PrioQueue.(insert empty 1 "hello");;
\end{caml_example}
在第二种形式中，当局部打开的主体本身由括号、大括号或方括号分隔时，可以省略局部打开的括号。例如：
\begin{caml_example}{toplevel}
  PrioQueue.[empty] = PrioQueue.([empty]);;
  PrioQueue.[|empty|] = PrioQueue.([|empty|]);;
   PrioQueue.{ contents = empty } = PrioQueue.({ contents = empty });;
\end{caml_example}
可以写作
\begin{caml_example}{toplevel}
  PrioQueue.[insert empty 1 "hello"];;
\end{caml_example}

还可以使用"include"语句将模块的组件复制到另一个模块中。这对于扩展现有模块特别实用。举例来说，我们可以添加一些函数，在优先队列为空时返回一个可选值，而不是一个异常。
\begin{caml_example}{toplevel}
  module PrioQueueOpt =
  struct
    include PrioQueue

    let remove_top_opt x =
      try Some(remove_top x) with Queue_is_empty -> None

    let extract_opt x =
      try Some(extract x) with Queue_is_empty -> None
  end;;
\end{caml_example}

\section{签名}

签名是结构的接口。签名指定了结构的哪些组件可以由外部访问，以及暴露哪些类型。签名可以用于隐藏结构的某些组件（例如本地函数定义），或者导出具有受限类型的组件。例如，下面的签名指定了三个优先队列操作："empty"、"insert"、"extract"，但没有指定辅助函数"remove_top"。类似地，它使"queue"类型抽象化（不以具体类型提供其实际表示）。
\begin{caml_example}{toplevel}
module type PRIOQUEUE =
  sig
    type priority = int         (* still concrete *)
    type 'a queue               (* now abstract *)
    val empty : 'a queue
    val insert : 'a queue -> int -> 'a -> 'a queue
    val extract : 'a queue -> int * 'a * 'a queue
    exception Queue_is_empty
  end;;
\end{caml_example}

通过这个签名限制"PrioQueue"结构会产生"PrioQueue"结构的另一个视图，其中"remove_top"函数不可以被访问，并且优先队列的实际表示是隐藏的：
\begin{caml_example}{toplevel}
module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;
AbstractPrioQueue.remove_top [@@expect error];;
AbstractPrioQueue.insert AbstractPrioQueue.empty 1 "hello";;
\end{caml_example}
这种限制也可以在结构的定义过程中执行，如：
\begin{verbatim}
module PrioQueue = (struct ... end : PRIOQUEUE);;
\end{verbatim}
也可以使用另一种语法完成限制：
\begin{verbatim}
module PrioQueue : PRIOQUEUE = struct ... end;;
\end{verbatim}

与模块一样，可以包含一个签名来将其组件复制到当前签名中。例如，我们可以使用"extract_opt"函数扩展"PRIOQUEUE"签名:

\begin{caml_example}{toplevel}
module type PRIOQUEUE_WITH_OPT =
  sig
    include PRIOQUEUE
    val extract_opt : 'a queue -> (int * 'a * 'a queue) option
  end;;
\end{caml_example}


\section{仿函数}

仿函数（functor，又称为函子）是从一个模块到另一个模块的“函数”。仿函数允许您创建参数化模块，然后将其他模块作为参数以获得特定的实现。例如，可以参数化"Set"模块，将"Set"实现为有序列表，以与任何提供元素类型和比较函数"compare"（如"OrderedString"）的模块一起工作：

\begin{caml_example}{toplevel}
type comparison = Less | Equal | Greater;;
module type ORDERED_TYPE =
  sig
    type t
    val compare: t -> t -> comparison
  end;;
module Set =
  functor (Elt: ORDERED_TYPE) ->
    struct
      type element = Elt.t
      type set = element list
      let empty = []
      let rec add x s =
        match s with
          [] -> [x]
        | hd::tl ->
           match Elt.compare x hd with
             Equal   -> s         (* x is already in s *)
           | Less    -> x :: s    (* x is smaller than all elements of s *)
           | Greater -> hd :: add x tl
      let rec member x s =
        match s with
          [] -> false
        | hd::tl ->
            match Elt.compare x hd with
              Equal   -> true     (* x belongs to s *)
            | Less    -> false    (* x is smaller than all elements of s *)
            | Greater -> member x tl
    end;;
\end{caml_example}
通过将"Set"仿函数应用到实现有序类型的结构中，我们可以得到该类型的集合运算：
\begin{caml_example}{toplevel}
module OrderedString =
  struct
    type t = string
    let compare x y = if x = y then Equal else if x < y then Less else Greater
  end;;
module StringSet = Set(OrderedString);;
StringSet.member "bar" (StringSet.add "foo" StringSet.empty);;
\end{caml_example}

\section{仿函数和类型抽象}

As in the "PrioQueue" example, it would be good style to hide the
actual implementation of the type "set", so that users of the
structure will not rely on sets being lists, and we can switch later
to another, more efficient representation of sets without breaking
their code. This can be achieved by restricting "Set" by a suitable
functor signature:
\begin{caml_example}{toplevel}
module type SETFUNCTOR =
  functor (Elt: ORDERED_TYPE) ->
    sig
      type element = Elt.t      (* concrete *)
      type set                  (* abstract *)
      val empty : set
      val add : element -> set -> set
      val member : element -> set -> bool
    end;;
module AbstractSet = (Set : SETFUNCTOR);;
module AbstractStringSet = AbstractSet(OrderedString);;
AbstractStringSet.add "gee" AbstractStringSet.empty;;
\end{caml_example}

In an attempt to write the type constraint above more elegantly,
one may wish to name the signature of the structure
returned by the functor, then use that signature in the constraint:
\begin{caml_example}{toplevel}
module type SET =
  sig
    type element
    type set
    val empty : set
    val add : element -> set -> set
    val member : element -> set -> bool
  end;;
module WrongSet = (Set : functor(Elt: ORDERED_TYPE) -> SET);;
module WrongStringSet = WrongSet(OrderedString);;
WrongStringSet.add "gee" WrongStringSet.empty [@@expect error];;
\end{caml_example}
The problem here is that "SET" specifies the type "element"
abstractly, so that the type equality between "element" in the result
of the functor and "t" in its argument is forgotten. Consequently,
"WrongStringSet.element" is not the same type as "string", and the
operations of "WrongStringSet" cannot be applied to strings.
As demonstrated above, it is important that the type "element" in the
signature "SET" be declared equal to "Elt.t"; unfortunately, this is
impossible above since "SET" is defined in a context where "Elt" does
not exist. To overcome this difficulty, OCaml provides a
"with type" construct over signatures that allows enriching a signature
with extra type equalities:
\begin{caml_example}{toplevel}
module AbstractSet2 =
  (Set : functor(Elt: ORDERED_TYPE) -> (SET with type element = Elt.t));;
\end{caml_example}

As in the case of simple structures, an alternate syntax is provided
for defining functors and restricting their result:
\begin{verbatim}
module AbstractSet2(Elt: ORDERED_TYPE) : (SET with type element = Elt.t) =
  struct ... end;;
\end{verbatim}

Abstracting a type component in a functor result is a powerful
technique that provides a high degree of type safety, as we now
illustrate. Consider an ordering over character strings that is
different from the standard ordering implemented in the
"OrderedString" structure. For instance, we compare strings without
distinguishing upper and lower case.
\begin{caml_example}{toplevel}
module NoCaseString =
  struct
    type t = string
    let compare s1 s2 =
      OrderedString.compare (String.lowercase_ascii s1) (String.lowercase_ascii s2)
  end;;
module NoCaseStringSet = AbstractSet(NoCaseString);;
NoCaseStringSet.add "FOO" AbstractStringSet.empty [@@expect error];;
\end{caml_example}
Note that the two types "AbstractStringSet.set" and
"NoCaseStringSet.set" are not compatible, and values of these
two types do not match. This is the correct behavior: even though both
set types contain elements of the same type (strings), they are built
upon different orderings of that type, and different invariants need
to be maintained by the operations (being strictly increasing for the
standard ordering and for the case-insensitive ordering). Applying
operations from "AbstractStringSet" to values of type
"NoCaseStringSet.set" could give incorrect results, or build
lists that violate the invariants of "NoCaseStringSet".

\section{Modules and separate compilation}

All examples of modules so far have been given in the context of the
interactive system. However, modules are most useful for large,
batch-compiled programs. For these programs, it is a practical
necessity to split the source into several files, called compilation
units, that can be compiled separately, thus minimizing recompilation
after changes.

In OCaml, compilation units are special cases of structures
and signatures, and the relationship between the units can be
explained easily in terms of the module system. A compilation unit \var{A}
comprises two files:
\begin{itemize}
\item the implementation file \var{A}".ml", which contains a sequence
of definitions, analogous to the inside of a "struct"\ldots"end"
construct;
\item the interface file \var{A}".mli", which contains a sequence of
specifications, analogous to the inside of a "sig"\ldots"end"
construct.
\end{itemize}
These two files together define a structure named \var{A} as if
the following definition was entered at top-level:
\begin{alltt}
module \var{A}: sig (* \hbox{contents of file} \var{A}.mli *) end
        = struct (* \hbox{contents of file} \var{A}.ml *) end;;
\end{alltt}
The files that define the compilation units can be compiled separately
using the "ocamlc -c" command (the "-c" option means ``compile only, do
not try to link''); this produces compiled interface files (with
extension ".cmi") and compiled object code files (with extension
".cmo"). When all units have been compiled, their ".cmo" files are
linked together using the "ocamlc" command. For instance, the following
commands compile and link a program composed of two compilation units
"Aux" and "Main":
\begin{verbatim}
$ ocamlc -c Aux.mli                     # produces aux.cmi
$ ocamlc -c Aux.ml                      # produces aux.cmo
$ ocamlc -c Main.mli                    # produces main.cmi
$ ocamlc -c Main.ml                     # produces main.cmo
$ ocamlc -o theprogram Aux.cmo Main.cmo
\end{verbatim}
The program behaves exactly as if the following phrases were entered
at top-level:
\begin{alltt}
module Aux: sig (* \rminalltt{contents of} Aux.mli *) end
          = struct (* \rminalltt{contents of} Aux.ml *) end;;
module Main: sig (* \rminalltt{contents of} Main.mli *) end
           = struct (* \rminalltt{contents of} Main.ml *) end;;
\end{alltt}
In particular, "Main" can refer to "Aux": the definitions and
declarations contained in "Main.ml" and "Main.mli" can refer to
definition in "Aux.ml", using the "Aux."\var{ident} notation, provided
these definitions are exported in "Aux.mli".

The order in which the ".cmo" files are given to "ocamlc" during the
linking phase determines the order in which the module definitions
occur. Hence, in the example above, "Aux" appears first and "Main" can
refer to it, but "Aux" cannot refer to "Main".

Note that only top-level structures can be mapped to
separately-compiled files, but neither functors nor module types.
However, all module-class objects can appear as components of a
structure, so the solution is to put the functor or module type
inside a structure, which can then be mapped to a file.
