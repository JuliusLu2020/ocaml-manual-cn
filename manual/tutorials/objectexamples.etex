\chapter{OCaml中的对象}
\label{c:objectexamples}
%HEVEA\cutname{objectexamples.html}
{\it (作者：Jérôme Vouillon、Didier Rémy、Jacques Garrigue)}

\bigskip

\noindent 本章概述了OCaml的面向对象特性。

请注意，OCaml中的对象、类和类型之间的关系与主流面向对象语言（如Java和C++）中的关系不同，因此您不应该假设类似的关键字具有相同的含义。与那些语言相比，在OCaml中使用面向对象特性的频率要低得多。使用OCaml时通常有更合适的选择，比如模块和函数。事实上，很多OCaml程序根本不使用对象。


\begin{htmlonly}

\ref{ss:classes-and-objects} 类和对象 \\
\ref{ss:immediate-objects} 直接对象 \\
\ref{ss:reference-to-self} 引用self \\
\ref{ss:initializers} 初始化器 \\
\ref{ss:virtual-methods} 虚方法 \\
\ref{ss:private-methods} 私有方法 \\
\ref{ss:class-interfaces} 类接口 \\
\ref{ss:inheritance} 继承 \\
\ref{ss:multiple-inheritance} 多继承 \\
\ref{ss:parameterized-classes} 参数化类 \\
\ref{ss:polymorphic-methods} 多态方法 \\
\ref{ss:using-coercions} 强制转换 \\
\ref{ss:functional-objects} 函数对象 \\
\ref{ss:cloning-objects} 克隆对象 \\
\ref{ss:recursive-classes} 递归类 \\
\ref{ss:binary-methods} Binary methods \\
\ref{ss:friends} 友元 \\

%%\ref{s:advanced-examples} {\bf Advanced examples}
%%
%%\ref{ss:bank-accounts} An extended example of bank accounts \\
%%\ref{ss:modules-as-classes} Simple modules as classes:
%%  \ref{module:string} Strings
%%  \ref{module:stack} Stacks
%%  \ref{module:hashtbl} Hash tables
%%  \ref{module:set} Sets \\
%%\ref{ss:subject-observer} The subject/observer pattern \\

\end{htmlonly}

\section{类与对象}
\label{ss:classes-and-objects}

下面的"point"类定义了一个实例变量"x"与两个方法"get_x"和"move"。其中实例变量的初始值是"0"。变量"x"被声明为可变的，因此"move"方法可以更改它的值。
\begin{caml_example}{toplevel}
class point =
  object
    val mutable x = 0
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}

现在我们创建一个"point"类的实例，点"p"。
\begin{caml_example}{toplevel}
let p = new point;;
\end{caml_example}
需要注意，"p"的类型是"point"。这其实是由上面的类定义所自动定义的缩写。它代表对象类型"<get_x : int; move : int -> unit>"，该类型给出了"point"包含的方法及它们的类型。

我们现在可以调用"p"的一些方法：
\begin{caml_example}{toplevel}
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

类中变量的求值只在对象被创建时进行。因此，在下面的示例中，实例变量"x"被初始化为两个不同对象的不同值。
\begin{caml_example}{toplevel}
let x0 = ref 0;;
class point =
  object
    val mutable x = incr x0; !x0
    method get_x = x
    method move d = x <- x + d
  end;;
new point#get_x;;
new point#get_x;;
\end{caml_example}

"point"类还可以被抽象为"x"坐标的初值。
\begin{caml_example}{toplevel}
class point = fun x_init ->
  object
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
与函数定义一样，上面的定义可以缩写为：
\begin{caml_example}{toplevel}
class point x_init =
  object
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}
"point"类的一个实例现在是一个函数，该函数需要一个初始参数来创建一个点对象：
\begin{caml_example}{toplevel}
new point;;
let p = new point 7;;
\end{caml_example}
当然，参数"x_init"在定义的整个主体中都是可见的，包括方法。例如，下面类中的"get_offset"方法可以返回对象与其初始位置的相对位置。
\begin{caml_example}{toplevel}
class point x_init =
  object
    val mutable x = x_init
    method get_x = x
    method get_offset = x - x_init
    method move d = x <- x + d
  end;;
\end{caml_example}
%Instance variables can only be used inside methods. For instance it would
%not be possible to define
%\begin{caml_example}{toplevel}
%class point x_init =
%  object
%    val mutable x = x_init
%    val origin = x
%    method get_offset = x - origin
%    method move d = x <- x + d
%  end;;
%\end{caml_example}
在定义类的对象主体之前，可以对表达式进行求值和绑定。这对于增强不变式是有用的。例如，点可以被自动调整到坐标网格中最近的点，如下所示：
\begin{caml_example}{toplevel}
class adjusted_point x_init =
  let origin = (x_init / 10) * 10 in
  object
    val mutable x = origin
    method get_x = x
    method get_offset = x - origin
    method move d = x <- x + d
  end;;
\end{caml_example}
（当"x_init"坐标不在坐标网格上时，可能会引发异常）事实上，这里也可以通过使用"origin"的值调用"point"类的定义来获得相同的效果。
\begin{caml_example}{toplevel}
class adjusted_point x_init =  point ((x_init / 10) * 10);;
\end{caml_example}
另一种解决办法是在一个特殊的分配函数中进行调整：
\begin{caml_example}{toplevel}
let new_adjusted_point x_init = new point ((x_init / 10) * 10);;
\end{caml_example}
但是，前一种模式通常更合适，因为用于调整的代码是类定义的一部分，可以被继承。

这种机制提供了其他语言中的类构造函数。可以用这种方式定义几个构造函数来构建具有相同类中具备不同初始化模式的对象；另一种方法是使用初始化器，如下面的\ref{ss:initializers}节所述。

\section{直接对象}
\label{ss:immediate-objects}

还有另一种更直接的方法来创建对象：不通过类来创建它。

这种方法的语法与类表达式完全相同，但是结果是一个对象而不是一个类。本节其余部分中描述的所有结构也适用于直接对象。
\begin{caml_example}{toplevel}
let p =
  object
    val mutable x = 0
    method get_x = x
    method move d = x <- x + d
  end;;
p#get_x;;
p#move 3;;
p#get_x;;
\end{caml_example}

与类不能在表达式中定义这一点不同，直接对象可以出现在任何地方，并使用它们所在环境中的变量。
\begin{caml_example}{toplevel}
let minmax x y =
  if x < y then object method min = x method max = y end
  else object method min = y method max = x end;;
\end{caml_example}

与类相比，直接对象有两个缺点：它们的类型没有缩写，并且不能被继承。但是这两个缺点在某些情况下可能是优点，我们将在\ref{ss:reference-to-self}和\ref{ss:parameterized-classes}节中进行阐释。

\section{引用self}
\label{ss:reference-to-self}

方法或初始化器可以调用self（即当前对象）上的方法。为此，必须显式地将self绑定到变量"s" （事实上"s"可以是任何标识符，尽管我们通常会选择"self"这个名称）。
\begin{caml_example}{toplevel}
class printable_point x_init =
  object (s)
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
    method print = print_int s#get_x
  end;;
let p = new printable_point 7;;
p#print;;
\end{caml_example}
变量"s"会在方法调用时被动态地绑定。特别是，当"printable_point"类被继承时，变量"s"将被正确地绑定到子类的对象上。

self的一个常见问题是，由于它的类型可能在子类中被扩展，所以您不能预先固定它的类型。这里有一个简单的例子。
\begin{caml_example}{toplevel}
let ints = ref [];;
class my_int =
  object (self)
    method n = 1
    method register = ints := self :: !ints
  end [@@expect error];;
\end{caml_example}
您可以忽略报错消息的前两行。最后一行才是最重要的：把self放在外部引用中将使我们无法通过继承来拓展它。我们将在第\ref{ss:using-coercions}节中看到这个问题的解决方案。但是请注意，由于直接对象是不可扩展的，所以使用它们时不会遭遇这一问题。
\begin{caml_example}{toplevel}
let my_int =
  object (self)
    method n = 1
    method register = ints := self :: !ints
  end;;
\end{caml_example}

\section{初始化器}
\label{ss:initializers}

类定义中的let绑定在对象被构建前被执行。我们也可以在构建对象之后立即执行其他表达式。这样的代码可以被编写为一个隐藏的匿名方法，我们称之为初始化器（"initializer"）。因此，初始化器可以访问self和实例变量。
\begin{caml_example}{toplevel}
class printable_point x_init =
  let origin = (x_init / 10) * 10 in
  object (self)
    val mutable x = origin
    method get_x = x
    method move d = x <- x + d
    method print = print_int self#get_x
    initializer print_string "new point at "; self#print; print_newline ()
  end;;
let p = new printable_point 17;;
\end{caml_example}
初始化器是无法被重载的。相反，所有初始化器都是按顺序被执行的。初始化器对于保持不变式特别实用。另一个例子可以在\ref{ss:bank-accounts}节中看到。

\section{虚方法}
\label{ss:virtual-methods}

我们可以使用关键字"virtual"声明一个方法，但不实际定义它。这个方法将在随后的子类中提供。这种方法被称为虚方法。包含虚方法的类必须被包换"virtual"标记，并且不能被实例化（也就是说，不能创建该类的任何对象）。该类的定义仍然会定义类型缩写（将虚方法视为其他方法）。
\begin{caml_example}{toplevel}
class virtual abstract_point x_init =
  object (self)
    method virtual get_x : int
    method get_offset = self#get_x - x_init
    method virtual move : int -> unit
  end;;
class point x_init =
  object
    inherit abstract_point x_init
    val mutable x = x_init
    method get_x = x
    method move d = x <- x + d
  end;;
\end{caml_example}

实例变量也可以被声明为虚变量，其效果与方法相同。
\begin{caml_example}{toplevel}
class virtual abstract_point2 =
  object
    val mutable virtual x : int
    method move d = x <- x + d
  end;;
class point2 x_init =
  object
    inherit abstract_point2
    val mutable x = x_init
    method get_offset = x - x_init
  end;;
\end{caml_example}

\section{私有方法}
\label{ss:private-methods}

私有方法是不出现在对象接口中的方法，它们只能被同一对象的其他方法调用。
\begin{caml_example}{toplevel}
class restricted_point x_init =
  object (self)
    val mutable x = x_init
    method get_x = x
    method private move d = x <- x + d
    method bump = self#move 1
  end;;
let p = new restricted_point 0;;
p#move 10 [@@expect error] ;;
p#bump;;
\end{caml_example}
请注意，这与Java或C++中的私有方法和受保护方法不同，后者可以从同一类的其他对象调用。这是OCaml中类型和类之间独立性的直接结果：两个不相关的类可能产生相同类型的对象，这意味着我们无法在类型上确保某一对象来自特定的类。然而，在\ref{ss:friends}节中给出了友元的编写方式。

私有方法是会被子类继承的（默认情况下它们在子类中是可见的），除非它们被签名隐藏，如下所示。

同时，私有方法可以在子类中被转化为公有。
\begin{caml_example}{toplevel}
class point_again x =
  object (self)
    inherit restricted_point x
    method virtual move : _
  end;;
\end{caml_example}
这里的"virtual"标记只用于声明一个方法，但不提供其定义。由于我们没有添加私有标记，这使得该方法成为公有的，并保留了原始定义。

另一种定义方式是
\begin{caml_example}{toplevel}
class point_again x =
  object (self : < move : _; ..> )
    inherit restricted_point x
  end;;
\end{caml_example}
self的类型约束要求使用公有的"move"方法，这足以重载"private"标记。

可以认为私有方法应该在子类中保持私有。然而，由于该方法在子类中是可见的，所以总是可以选取它的代码并定义运行该代码的同名方法，因此另一个（较重的）解决方案是：
\begin{caml_example}{toplevel}
class point_again x =
  object
    inherit restricted_point x as super
    method move = super#move
  end;;
\end{caml_example}

当然，私有方法也可以是虚拟的。其关键字必须按此顺序出现"method private virtual"。

\section{类接口}
\label{ss:class-interfaces}


%XXX Differentiate class type and class interface ?

类接口是从类定义中推导出来的。它们也可以直接被定义，并用于限制类的类型。像类声明一样，它们还定义了一个新的类型缩写。
\begin{caml_example}{toplevel}
class type restricted_point_type =
  object
    method get_x : int
    method bump : unit
end;;
fun (x : restricted_point_type) -> x;;
\end{caml_example}
除了用于程序文档，类接口还可以被用来约束类的类型。具体的实例变量和私有方法都可以通过类的类型约束来隐藏。但是，公有方法和虚拟成员则无法被隐藏。
\begin{caml_example}{toplevel}
class restricted_point' x = (restricted_point x : restricted_point_type);;
\end{caml_example}
或者，相当于：
\begin{caml_example}{toplevel}
class restricted_point' = (restricted_point : int -> restricted_point_type);;
\end{caml_example}
类的接口也可以在模块签名中指定，并用于限制模块的推导签名。
\begin{caml_example}{toplevel}
module type POINT = sig
  class restricted_point' : int ->
    object
      method get_x : int
      method bump : unit
    end
end;;
module Point : POINT = struct
  class restricted_point' = restricted_point
end;;
\end{caml_example}

\section{继承}
\label{ss:inheritance}

我们通过定义从"point"类继承的"colored_point"类来说明继承。这个类具备"point"类中的所有的实例变量和方法，与一个新的实例变量"c"和一个新的"color"方法。
\begin{caml_example}{toplevel}
class colored_point x (c : string) =
  object
    inherit point x
    val c = c
    method color = c
  end;;
let p' = new colored_point 5 "red";;
p'#get_x, p'#color;;
\end{caml_example}
"point"和"colored_point"具有不兼容的类型，因为"point"没有"color"方法。但是，下面的"get_x"函数是一个通用函数，它可以将"get_x"方法应用于任何具有此方法的对象"p"（可能还有其他的对象，它们由类型中的省略号表示）。因此，它同时适用于"point"和"colored_point"。
\begin{caml_example}{toplevel}
let get_succ_x p = p#get_x + 1;;
get_succ_x p + get_succ_x p';;
\end{caml_example}
在定义函数前不需要提前声明所使用的方法，如示例所示：
\begin{caml_example}{toplevel}
let set_x p = p#set_x;;
let incr p = set_x p (get_succ_x p);;
\end{caml_example}

\section{多继承}
\label{ss:multiple-inheritance}

OCaml允许多继承。其中只保留方法的最后一个定义：在子类中重新定义父类中可见的方法会覆盖父类中的定义。可以通过绑定相关的祖先来重用被覆盖方法的定义。下面，"super"被绑定到祖先"printable_point"上。"super"是一个伪值标识符，只能用于调用超类方法，如"super#print"。
\begin{caml_example}{toplevel}
class printable_colored_point y c =
  object (self)
    val c = c
    method color = c
    inherit printable_point y as super
    method! print =
      print_string "(";
      super#print;
      print_string ", ";
      print_string (self#color);
      print_string ")"
  end;;
let p' = new printable_colored_point 17 "red";;
p'#print;;
\end{caml_example}
隐藏在父类中的私有方法是不可见的，因此不会被覆盖。由于初始化器被视为私有方法，所以沿着类层次结构的所有初始化器都将按照引入它们的顺序被执行。

注意，为了清晰起见，方法"print"被通过"method"关键字与感叹号"!"显式地标记为覆盖另一个定义。如果方法print没有覆盖"printable_point"的"print"方法，编译器会抛出一个错误：
\begin{caml_example}{toplevel}[error]
  object
    method! m = ()
  end;;
\end{caml_example}

这个显式覆盖标记对"val"和"inherit"也同样适用：
\begin{caml_example}{toplevel}
class another_printable_colored_point y c c' =
  object (self)
  inherit printable_point y
  inherit! printable_colored_point y c
  val! c = c'
  end;;
\end{caml_example}

\section{参数化类}
\label{ss:parameterized-classes}

可以将ref类型作为一个对象来实现。不过以下的定义无法通过类型检查：
\begin{caml_example}{toplevel}[error]
class oref x_init =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
报错的原因是至少有一个方法具有多态类型（这里是存储在ref单元中值的类型），因此这个类应该是参数化的，或者方法的类型应该被限制为单态类型。类的单态实例可以定义为：
\begin{caml_example}{toplevel}
class oref (x_init:int) =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
注意，由于直接对象不定义类类型，因此它们没有这样的限制。
\begin{caml_example}{toplevel}
let new_oref x_init =
  object
    val mutable x = x_init
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
另一方面，用于多态ref的类必须在其声明中显式列出类型参数。类的类型参数被列在"["和"]"之间。类型参数还必须通过类型约束绑定到类主体中的某个位置。
\begin{caml_example}{toplevel}
class ['a] oref x_init =
  object
    val mutable x = (x_init : 'a)
    method get = x
    method set y = x <- y
  end;;
let r = new oref 1 in r#set 2; (r#get);;
\end{caml_example}
声明中的类型参数实际上可能在类定义的主体中受到约束。在类类型中，类型参数的实际值在"constraint"子句中显示。
\begin{caml_example}{toplevel}
class ['a] oref_succ (x_init:'a) =
  object
    val mutable x = x_init + 1
    method get = x
    method set y = x <- y
  end;;
\end{caml_example}
让我们考虑一个更复杂的例子：定义一个圆，其圆心可以是任何类型的点。我们在方法"move"中添加了一个额外的类型约束，因为类的类型参数不能忽略任何自由变量。
\begin{caml_example}{toplevel}
class ['a] circle (c : 'a) =
  object
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = (center#move : int -> unit)
  end;;
\end{caml_example}
我们可以使用"constraint"子句实现"circle"另一种定义方式。"constraint"子句中使用的"#point"类型是由"point"类的定义生成的缩写。这个缩写能够与属于"point"类子类的任何对象的类型相匹配。它实际上可以被扩展为"< get_x : int; move : int -> unit; .. >"。因此我们可以给出"circle"的替代定义如下，该定义对其参数有略微强一些的约束，因为我们现在期望"center"具备"get_x"方法。
\begin{caml_example}{toplevel}
class ['a] circle (c : 'a) =
  object
    constraint 'a = #point
    val mutable center = c
    method center = center
    method set_center c = center <- c
    method move = center#move
  end;;
\end{caml_example}
"colored_circle"类是"circle"类的一个特别版本，它要求"center"的类型与"#colored_point"一致，并包括方法"color"。注意，在定制参数化类时，类型参数的实例必须始终被显式给出。它同样被写在"["和"]"之间。
\begin{caml_example}{toplevel}
class ['a] colored_circle c =
  object
    constraint 'a = #colored_point
    inherit ['a] circle c
    method color = center#color
  end;;
\end{caml_example}

\section{Polymorphic methods}
\label{ss:polymorphic-methods}

While parameterized classes may be polymorphic in their contents, they
are not enough to allow polymorphism of method use.

A classical example is defining an iterator.
\begin{caml_example}{toplevel}
List.fold_left;;
class ['a] intlist (l : int list) =
  object
    method empty = (l = [])
    method fold f (accu : 'a) = List.fold_left f accu l
  end;;
\end{caml_example}
At first look, we seem to have a polymorphic iterator, however this
does not work in practice.
\begin{caml_example}{toplevel}
let l = new intlist [1; 2; 3];;
l#fold (fun x y -> x+y) 0;;
l;;
l#fold (fun s x -> s ^ string_of_int x ^ " ") "" [@@expect error];;
\end{caml_example}
Our iterator works, as shows its first use for summation. However,
since objects themselves are not polymorphic (only their constructors
are), using the "fold" method fixes its type for this individual object.
Our next attempt to use it as a string iterator fails.

The problem here is that quantification was wrongly located: it is
not the class we want to be polymorphic, but the "fold" method.
This can be achieved by giving an explicitly polymorphic type in the
method definition.
\begin{caml_example}{toplevel}
class intlist (l : int list) =
  object
    method empty = (l = [])
    method fold : 'a. ('a -> int -> 'a) -> 'a -> 'a =
      fun f accu -> List.fold_left f accu l
  end;;
let l = new intlist [1; 2; 3];;
l#fold (fun x y -> x+y) 0;;
l#fold (fun s x -> s ^ string_of_int x ^ " ") "";;
\end{caml_example}
As you can see in the class type shown by the compiler, while
polymorphic method types must be fully explicit in class definitions
(appearing immediately after the method name), quantified type
variables can be left implicit in class descriptions. Why require types
to be explicit? The problem is that "(int -> int -> int) -> int ->
int" would also be a valid type for "fold", and it happens to be
incompatible with the polymorphic type we gave (automatic
instantiation only works for toplevel types variables, not for inner
quantifiers, where it becomes an undecidable problem.) So the compiler
cannot choose between those two types, and must be helped.

However, the type can be completely omitted in the class definition if
it is already known, through inheritance or type constraints on self.
Here is an example of method overriding.
\begin{caml_example*}{toplevel}
class intlist_rev l =
  object
    inherit intlist l
    method! fold f accu = List.fold_left f accu (List.rev l)
  end;;
\end{caml_example*}
The following idiom separates description and definition.
\begin{caml_example*}{toplevel}
class type ['a] iterator =
  object method fold : ('b -> 'a -> 'b) -> 'b -> 'b end;;
class intlist' l =
  object (self : int #iterator)
    method empty = (l = [])
    method fold f accu = List.fold_left f accu l
  end;;
\end{caml_example*}
Note here the "(self : int #iterator)" idiom, which ensures that this
object implements the interface "iterator".

Polymorphic methods are called in exactly the same way as normal
methods, but you should be aware of some limitations of type
inference.  Namely, a polymorphic method can only be called if its
type is known at the call site.  Otherwise, the method will be assumed
to be monomorphic, and given an incompatible type.
\begin{caml_example}{toplevel}
let sum lst = lst#fold (fun x y -> x+y) 0;;
sum l [@@expect error];;
\end{caml_example}
The workaround is easy: you should put a type constraint on the
parameter.
\begin{caml_example}{toplevel}
let sum (lst : _ #iterator) = lst#fold (fun x y -> x+y) 0;;
\end{caml_example}
Of course the constraint may also be an explicit method type.
Only occurences of quantified variables are required.
\begin{caml_example}{toplevel}
let sum lst =
  (lst : < fold : 'a. ('a -> _ -> 'a) -> 'a -> 'a; .. >)#fold (+) 0;;
\end{caml_example}

Another use of polymorphic methods is to allow some form of implicit
subtyping in method arguments. We have already seen in section
\ref{ss:inheritance} how some functions may be polymorphic in the
class of their argument. This can be extended to methods.
\begin{caml_example}{toplevel}
class type point0 = object method get_x : int end;;
class distance_point x =
  object
    inherit point x
    method distance : 'a. (#point0 as 'a) -> int =
      fun other -> abs (other#get_x - x)
  end;;
let p = new distance_point 3 in
(p#distance (new point 8), p#distance (new colored_point 1 "blue"));;
\end{caml_example}
Note here the special syntax "(#point0 as 'a)" we have to use to
quantify the extensible part of "#point0". As for the variable binder,
it can be omitted in class specifications. If you want polymorphism
inside object field it must be quantified independently.
\begin{caml_example}{toplevel}
class multi_poly =
  object
    method m1 : 'a. (< n1 : 'b. 'b -> 'b; .. > as 'a) -> _ =
      fun o -> o#n1 true, o#n1 "hello"
    method m2 : 'a 'b. (< n2 : 'b -> bool; .. > as 'a) -> 'b -> _ =
      fun o x -> o#n2 x
  end;;
\end{caml_example}
In method "m1", "o" must be an object with at least a method "n1",
itself polymorphic.  In method "m2", the argument of "n2" and "x" must
have the same type, which is quantified at the same level as "'a".

\section{Using coercions}
\label{ss:using-coercions}

Subtyping is never implicit.  There are, however, two ways to perform
subtyping.  The most general construction is fully explicit: both the
domain and the codomain of the type coercion must be given.

We have seen that points and colored points have incompatible types.
For instance, they cannot be mixed in the same list. However, a
colored point can be coerced to a point, hiding its "color" method:
\begin{caml_example}{toplevel}
let colored_point_to_point cp = (cp : colored_point :> point);;
let p = new point 3 and q = new colored_point 4 "blue";;
let l = [p; (colored_point_to_point q)];;
\end{caml_example}
An object of type "t" can be seen as an object of type "t'"
only if "t" is a subtype of "t'". For instance, a point cannot be
seen as a colored point.
\begin{caml_example}{toplevel}[error]
(p : point :> colored_point);;
\end{caml_example}
Indeed, narrowing coercions without runtime checks would be unsafe.
Runtime type checks might raise exceptions, and they would require
the presence of type information at runtime, which is not the case in
the OCaml system.
For these reasons, there is no such operation available in the language.

Be aware that subtyping and inheritance are not related.  Inheritance is a
syntactic relation between classes while subtyping is a semantic relation
between types.  For instance, the class of colored points could have been
defined directly, without inheriting from the class of points; the type of
colored points would remain unchanged and thus still be a subtype of
points.
% Conversely, the class "int_comparable" inherits from class
%"comparable", but type "int_comparable" is not a subtype of "comparable".
%\begin{caml_example}{toplevel}
%function x -> (x : int_comparable :> comparable);;
%\end{caml_example}

The domain of a coercion can often be omitted. For instance, one can
define:
\begin{caml_example}{toplevel}
let to_point cp = (cp :> point);;
\end{caml_example}
In this case, the function "colored_point_to_point" is an instance of the
function "to_point". This is not always true, however. The fully
explicit coercion  is more precise and is sometimes  unavoidable.
Consider, for example, the following class:
\begin{caml_example}{toplevel}
class c0 = object method m = {< >} method n = 0 end;;
\end{caml_example}
The object type "c0" is an abbreviation for "<m : 'a; n : int> as 'a".
Consider now the type declaration:
\begin{caml_example}{toplevel}
class type c1 =  object method m : c1 end;;
\end{caml_example}
The object type "c1" is an abbreviation for the type "<m : 'a> as 'a".
The coercion from an object of type "c0" to an object of type "c1" is
correct:
\begin{caml_example}{toplevel}
fun (x:c0) -> (x : c0 :> c1);;
\end{caml_example}
%%% FIXME come up with a better example.
% However, the domain of the coercion cannot be omitted here:
% \begin{caml_example}{toplevel}
% fun (x:c0) -> (x :> c1);;
% \end{caml_example}
However, the domain of the coercion cannot always be omitted.
In that case, the solution is to use the explicit form.
%
Sometimes, a change in the class-type definition can also solve the problem
\begin{caml_example}{toplevel}
class type c2 = object ('a) method m : 'a end;;
fun (x:c0) -> (x :> c2);;
\end{caml_example}
While class types "c1" and "c2" are different, both object types
"c1" and "c2" expand to the same object type (same method names and types).
Yet, when the domain of a coercion is left implicit and its co-domain
is an abbreviation of a known class type, then the class type, rather
than the object type, is used to derive the coercion function. This
allows leaving the domain implicit in most cases when coercing form a
subclass to its superclass.
%
The type of a coercion can always be seen as below:
\begin{caml_example}{toplevel}
let to_c1 x = (x :> c1);;
let to_c2 x = (x :> c2);;
\end{caml_example}
Note the difference between these two coercions: in the case of "to_c2",
the type
"#c2 = < m : 'a; .. > as 'a" is polymorphically recursive (according
to the explicit recursion in the class type of "c2"); hence the
success of applying this coercion to an object of class "c0".
On the other hand, in the first case, "c1" was only expanded and
unrolled twice to obtain "< m : < m : c1; .. >; .. >" (remember "#c1 =
< m : c1; .. >"), without introducing recursion.
You may also note that the type of "to_c2" is "#c2 -> c2" while
the type of "to_c1" is more general than "#c1 -> c1". This is not always true,
since there are class types for which some instances of "#c" are not subtypes
of "c", as explained in section~\ref{ss:binary-methods}. Yet, for
parameterless classes the coercion "(_ :> c)" is always more general than
"(_ : #c :> c)".
%If a class type exposes the type of self through one of its parameters, this
%is no longer true. Here is a counter-example.
%\begin{caml_example}{toplevel}
%class type ['a] c = object ('a) method m : 'a end;;
%let to_c x = (x :> _ c);;
%\end{caml_example}


A common problem may occur when one tries to define a coercion to a
class "c" while defining class "c". The problem is due to the type
abbreviation not being completely defined yet, and so its subtypes are not
clearly known.  Then, a coercion "(_ :> c)" or "(_ : #c :> c)" is taken to be
the identity function, as in
\begin{caml_example}{toplevel}
function x -> (x :> 'a);;
\end{caml_example}
As a consequence, if the coercion is applied to "self", as in the
following example, the type of "self" is unified with the closed type
"c" (a closed object type is an object type without ellipsis).  This
would constrain the type of self be closed and is thus rejected.
Indeed, the type of self cannot be closed: this would prevent any
further extension of the class. Therefore, a type error is generated
when the unification of this type with another type would result in a
closed object type.
\begin{caml_example}{toplevel}[error]
class c = object method m = 1 end
and d = object (self)
  inherit c
  method n = 2
  method as_c = (self :> c)
end;;
\end{caml_example}
However, the most common instance of this problem, coercing self to
its current class, is detected as a special case by the type checker,
and properly typed.
\begin{caml_example}{toplevel}
class c = object (self) method m = (self :> c) end;;
\end{caml_example}
This allows the following idiom, keeping a list of all objects
belonging to a class or its subclasses:
\begin{caml_example}{toplevel}
let all_c = ref [];;
class c (m : int) =
  object (self)
    method m = m
    initializer all_c := (self :> c) :: !all_c
  end;;
\end{caml_example}
This idiom can in turn be used to retrieve an object whose type has
been weakened:
\begin{caml_example}{toplevel}
let rec lookup_obj obj = function [] -> raise Not_found
  | obj' :: l ->
     if (obj :> < >) = (obj' :> < >) then obj' else lookup_obj obj l ;;
let lookup_c obj = lookup_obj obj !all_c;;
\end{caml_example}
The type "< m : int >" we see here is just the expansion of "c", due
to the use of a reference; we have succeeded in getting back an object
of type "c".

\medskip
The previous coercion problem can often be avoided by first
defining the abbreviation, using a class type:
\begin{caml_example}{toplevel}
class type c' = object method m : int end;;
class c : c' = object method m = 1 end
and d = object (self)
  inherit c
  method n = 2
  method as_c = (self :> c')
end;;
\end{caml_example}
It is also possible to use a virtual class. Inheriting from this class
simultaneously forces all methods of "c" to have the same
type as the methods of "c'".
\begin{caml_example}{toplevel}
class virtual c' = object method virtual m : int end;;
class c = object (self) inherit c' method m = 1 end;;
\end{caml_example}
One could think of defining the type abbreviation directly:
\begin{caml_example*}{toplevel}
type c' = <m : int>;;
\end{caml_example*}
However, the abbreviation "#c'" cannot be defined directly in a similar way.
It can only be defined by a class or a class-type definition.
This is because a "#"-abbreviation carries an implicit anonymous
variable ".." that cannot be explicitly named.
The closer you get to it is:
\begin{caml_example*}{toplevel}
type 'a c'_class = 'a constraint 'a = < m : int; .. >;;
\end{caml_example*}
with an extra type variable capturing the open object type.

\section{Functional objects}
\label{ss:functional-objects}

It is possible to write a version of class "point" without assignments
on the instance variables. The override construct "{< ... >}" returns a copy of
``self'' (that is, the current object), possibly changing the value of
some instance variables.
\begin{caml_example}{toplevel}
class functional_point y =
  object
    val x = y
    method get_x = x
    method move d = {< x = x + d >}
  end;;
let p = new functional_point 7;;
p#get_x;;
(p#move 3)#get_x;;
p#get_x;;
\end{caml_example}
Note that the type abbreviation "functional_point" is recursive, which can
be seen in the class type of "functional_point": the type of self is "'a"
and "'a" appears inside the type of the method "move".

The above definition of "functional_point" is not equivalent
to the following:
\begin{caml_example}{toplevel}
class bad_functional_point y =
  object
    val x = y
    method get_x = x
    method move d = new bad_functional_point (x+d)
  end;;
\end{caml_example}
While objects of either class will behave the same, objects of their
subclasses will be different. In a subclass of "bad_functional_point",
the method "move" will
keep returning an object of the parent class.  On the contrary, in a
subclass of "functional_point", the method "move" will return an
object of the subclass.

Functional update is often used in conjunction with binary methods
as illustrated in section \ref{module:string}.

\section{Cloning objects}
\label{ss:cloning-objects}

Objects can also be cloned, whether they are functional or imperative.
The library function "Oo.copy" makes a shallow copy of an object. That is,
it returns a new object that has the same methods and instance
variables as its argument. The
instance variables are copied but their contents are shared.
Assigning a new value to an instance variable of the copy (using a method
call) will not affect instance variables of the original, and conversely.
A deeper assignment (for example if the instance variable is a reference cell)
will of course affect both the original and the copy.

The type of "Oo.copy" is the following:
\begin{caml_example}{toplevel}
Oo.copy;;
\end{caml_example}
The keyword "as" in that type binds the type variable "'a" to
the object type "< .. >".  Therefore, "Oo.copy" takes an object with
any methods (represented by the ellipsis), and returns an object of
the same type. The type of "Oo.copy" is different from type "< .. > ->
< .. >" as each ellipsis represents a different set of methods.
Ellipsis actually behaves as a type variable.
\begin{caml_example}{toplevel}
let p = new point 5;;
let q = Oo.copy p;;
q#move 7; (p#get_x, q#get_x);;
\end{caml_example}
In fact, "Oo.copy p" will behave as "p#copy" assuming that a public
method "copy" with body "{< >}" has been defined in the class of "p".

Objects can be compared using the generic comparison functions "=" and "<>".
Two objects are equal if and only if they are physically equal. In
particular, an object and its copy are not equal.
\begin{caml_example}{toplevel}
let q = Oo.copy p;;
p = q, p = p;;
\end{caml_example}
Other generic comparisons such as ("<", "<=", ...) can also be used on
objects.  The
relation "<" defines an unspecified but strict ordering on objects.  The
ordering relationship between two objects is fixed once for all after the
two objects have been created and it is not affected by mutation of fields.

Cloning and override have a non empty intersection.
They are interchangeable when used within an object and without
overriding any field:
\begin{caml_example}{toplevel}
class copy =
  object
    method copy = {< >}
  end;;
class copy =
  object (self)
    method copy = Oo.copy self
  end;;
\end{caml_example}
Only the override can be used to actually override fields, and
only the "Oo.copy" primitive can be used externally.

Cloning can also be used to provide facilities for saving and
restoring the state of objects.
\begin{caml_example}{toplevel}
class backup =
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< copy = None >}
    method restore = match copy with Some x -> x | None -> self
  end;;
\end{caml_example}
The above definition will only backup one level.
The backup facility can be added to any class by using multiple inheritance.
\begin{caml_example}{toplevel}
class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;
let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2;
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}
We can define a variant of backup that retains all copies. (We also
add a method "clear" to manually erase all copies.)
\begin{caml_example}{toplevel}
class backup =
  object (self : 'mytype)
    val mutable copy = None
    method save = copy <- Some {< >}
    method restore = match copy with Some x -> x | None -> self
    method clear = copy <- None
  end;;
\end{caml_example}
\begin{caml_example}{toplevel}
class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;
let p = new backup_ref 0  in
p # save; p # set 1; p # save; p # set 2;
[get p 0; get p 1; get p 2; get p 3; get p 4];;
\end{caml_example}



\section{Recursive classes}
\label{ss:recursive-classes}

Recursive classes can be used to define objects whose types are
mutually recursive.
\begin{caml_example}{toplevel}
class window =
  object
    val mutable top_widget = (None : widget option)
    method top_widget = top_widget
  end
and widget (w : window) =
  object
    val window = w
    method window = window
  end;;
\end{caml_example}
Although their types are mutually recursive, the classes "widget" and
"window" are themselves independent.


\section{Binary methods}
\label{ss:binary-methods}

A binary method is a method which takes an argument of the same type
as self. The class "comparable" below is a template for classes with a
binary method "leq" of type "'a -> bool" where the type variable "'a"
is bound to the type of self. Therefore, "#comparable" expands to "<
leq : 'a -> bool; .. > as 'a".  We see here that the binder "as" also
allows writing recursive types.
\begin{caml_example}{toplevel}
class virtual comparable =
  object (_ : 'a)
    method virtual leq : 'a -> bool
  end;;
\end{caml_example}
We then define a subclass "money" of "comparable". The class "money"
simply wraps floats as comparable objects. We will extend it below with
more operations. We have to use a type constraint on the class parameter "x"
because the primitive "<=" is a polymorphic function in
OCaml.  The "inherit" clause ensures that the type of objects
of this class is an instance of "#comparable".
\begin{caml_example}{toplevel}
class money (x : float) =
  object
    inherit comparable
    val repr = x
    method value = repr
    method leq p = repr <= p#value
  end;;
\end{caml_example}
% not explained: mutability can be hidden
Note that the type "money" is not a subtype of type
"comparable", as the self type appears in contravariant position
in the type of method "leq".
Indeed, an object "m" of class "money" has a method "leq"
that expects an argument of type "money" since it accesses
its "value" method.  Considering "m" of type "comparable" would allow a
call to method "leq" on "m" with an argument that does not have a method
"value", which would be an error.

Similarly, the type "money2" below is not a subtype of type "money".
\begin{caml_example}{toplevel}
class money2 x =
  object
    inherit money x
    method times k = {< repr = k *. repr >}
  end;;
\end{caml_example}
It is however possible to define functions that manipulate objects of
type either "money" or "money2": the function "min"
will return the minimum of any two objects whose type unifies with
"#comparable". The type of "min" is not the same as "#comparable ->
#comparable -> #comparable", as the abbreviation "#comparable" hides a
type variable (an ellipsis). Each occurrence of this abbreviation
generates a new variable.
\begin{caml_example}{toplevel}
let min (x : #comparable) y =
  if x#leq y then x else y;;
\end{caml_example}
This function can be applied to objects of type "money"
or "money2".
\begin{caml_example}{toplevel}
(min (new money  1.3) (new money 3.1))#value;;
(min (new money2 5.0) (new money2 3.14))#value;;
\end{caml_example}

More examples of binary methods can be found in sections
\ref{module:string} and \ref{module:set}.

Note the use of override for method "times".
Writing  "new money2 (k *. repr)" instead of  "{< repr = k *. repr >}"
would not behave well with inheritance: in a subclass "money3" of "money2"
the "times" method would return an object of class "money2" but not of class
"money3" as would be expected.

The class "money" could naturally carry another binary method. Here is a
direct definition:
\begin{caml_example}{toplevel}
class money x =
  object (self : 'a)
    val repr = x
    method value = repr
    method print = print_float repr
    method times k = {< repr = k *. x >}
    method leq (p : 'a) = repr <= p#value
    method plus (p : 'a) = {< repr = x +. p#value >}
  end;;
\end{caml_example}

\section{Friends}
\label{ss:friends}

The above class "money" reveals a problem that often occurs with binary
methods.  In order to interact with other objects of the same class, the
representation of "money" objects must be revealed, using a method such as
"value". If we remove all binary methods (here "plus" and "leq"),
the representation can easily be hidden inside objects by removing the method
"value" as well. However, this is not possible as soon as some binary
method requires access to the representation of objects of the same
class (other than self).
\begin{caml_example}{toplevel}
class safe_money x =
  object (self : 'a)
    val repr = x
    method print = print_float repr
    method times k = {< repr = k *. x >}
  end;;
\end{caml_example}
Here, the representation of the object is known only to a particular object.
To make it available to other objects of the same class, we are forced to
make it available to the whole world. However we can easily restrict the
visibility of the representation using the module system.
\begin{caml_example*}{toplevel}
module type MONEY =
  sig
    type t
    class c : float ->
      object ('a)
        val repr : t
        method value : t
        method print : unit
        method times : float -> 'a
        method leq : 'a -> bool
        method plus : 'a -> 'a
      end
  end;;
module Euro : MONEY =
  struct
    type t = float
    class c x =
      object (self : 'a)
        val repr = x
        method value = repr
        method print = print_float repr
        method times k = {< repr = k *. x >}
        method leq (p : 'a) = repr <= p#value
        method plus (p : 'a) = {< repr = x +. p#value >}
      end
  end;;
\end{caml_example*}
Another example of friend functions may be found in section
\ref{module:set}.  These examples occur when a group of objects (here
objects of the same class) and functions should see each others internal
representation, while their representation should be hidden from the
outside. The solution is always to define all friends in the same module,
give access to the representation and use a signature constraint to make the
representation abstract outside the module.



% LocalWords:  typecheck monomorphic uncaptured Subtyping subtyping leq repr Oo
% LocalWords:  val sig bool Euro struct OCaml Vouillon Didier int ref incr init
% LocalWords:  succ mytype rec

